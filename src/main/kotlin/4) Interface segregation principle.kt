class `4) Interface segregation principle` {
    /*

    Оригинальная формулировка мартина:
    Make fine grained interfaces that are client specific.


    Программные сущности не должны зависить от методов которые они не используют

     Или
     Нельзя заставлять клиента реализовывать интерфейс которым он не пользуется


     Например:
     Интерфейс имеет три метода, первый класс который наследуется от интерфейса использует все три метода, затем
     необходимо реализовать новый класс, который использует только методы 1,2. На третий метод мы делае заглушку которая
     ничего не делает.
     Далее возникает необходимость реализовать еще один класс, который использует уже методы 1,3.
     Чтобы избежать путаницы и ошибок можно сделать иначе:
     Разбить изначальный интерфейс на три разных, каждый из которых будет иметь лишь один метод.
     !Делать суперобщее решения это скорее антипаттерн!

     Поэтому необходимо разделять всеобъемлющие интерфейсы на более узконаправленные интерфейсы, решающие
     узконаправленную задачу.


    Преимущества:
    1)Избавляем программные сущности от методов, которые они не используют
    2) Получаем более предсказуемую работу
    3) Код становится менее связанным
     */
}


