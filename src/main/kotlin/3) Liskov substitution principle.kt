class `Liskov substitution principle` {
    /*

    Определение Мартина:
    Подтипы должны быть заменяемы на своих базовые типы

    Определения:
    Функции которые используют родительский тип должны точно так же работать с дочерними классами
    или
    Наследуемый класс должен дополнять, а не замещать поведение базового класса


    Например: Есть базовый класс который имеет функцию print(), и мы расчитываем что все его наследники имеют
    данный метод, если же какой то из наследников вместое вывода в консоль возвращает null, или делает что-то необычное,
    это является нарушением принципа

    >Подтип может ослабить (но не усилить) предварительное условие для переопределяемого им метода
    Так же наследуемые классы не должны нарушить логику заданную в родительском классе.
    Если родительский класс имеет несколько переменных x,y и условия что x<y, то и в дочерних классах эта логика не должна
    быть нарушена


    Преимущества:
    1) Помогает проектировать правильные иерархии наследования (Предотвращение появления иерархий нарушающих принцип
    открытости
 */
}


//////////////////////////////////////////////Пример 1
open class Database{
    fun connect(){}
    fun read(){}
    fun write(){}
    //fun joinTables(){} //Лишний здесь метод, потому что может быть использован не во всех наследниках

}
class SQLDatabase(): Database() {
    fun joinTables(){
        //Doing smth
    }
}

class NOSQLDatabase(): Database() {
    //joinTables отсутствует в силу особенностей даннной реализации базы данных
    fun createIndex(){
        //Doing smth
    }
}

